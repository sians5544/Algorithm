// 최대 부분 증가 수열을 찾아라 
// 원소가 n개인 배열의 일부 원소를 골라내서 만든 수열 중 각 원소가
//이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 
// 최장 증가 부분 수열 

// 중간에 끊아쟏도 됨  

// 숫자를 뽑아서 수열을 만들건데 순서 바뀌면 안되고 원래 순서로 가야하는데 그 수열들이 증가하는 수열  수열의 길이가 길다는것은 원소의 개수가 많다는 것 
// 나보다 작은 애들 중에서 가장 긴 애들 뒤에 붙는다 

// dy에다가 뭘 저장할지가 핵심이다  -> 5,,6 번 등으로 넘어가면 걔네 를 다 헀을 때 최대값  ,앞에 애들이 적용되었을 때 쓸 수 있는 최대값을 저장하겠다 
// 자기가 포함되니까 

// 순서만 유지해서 뽑아내면서 가장긴 수열을 뽑으라는 것이다 
// dy[i] -> arr 의 i번째 숫자가 증가수열의 마지막 숫자라고 생각하고 최대 길이의 값
//ex dy[3] 3번째 인덱스의 8이라는 값이 최대 증가 수열의 길이 값이 여기에 들어가는 것이다 


// 이문제는 배열의 순서는 유지하고 가장 원소 값이 많은 (가장 긴) 수열을 뽑으라는 문제이다 

function solution(nums){
  let answer = 0;

  let dy = Array(nums.length).fill(0); // dy[i] -> nums 의 i번째 숫자가 증가수열의 마지막 숫자라고 생각하고 최대 길이의 값을 저장하고 있는 배열 
  
  dy[0] = 1; // 첫번째 숫자 하나만 있으니까 길이 1 선언 

  for(let i = 1; i<nums.length; i++){
    let max = 0; // max 를 0으로 해주는 이유는 j을 돌다가 앞에 항이 될것이 하나도 없다면 0+1 자기 자신 해줘야하기때문 

    // 자기 앞에 항의 작은 값이 있는지 확인 
    
    for(let j = i-1; j>=0; j--){ // 처음부터 나보다 앞에 있는 애들까지 돌려서  작은 애 인덱스에 해당하는 값 뒤에 붙는다 
      if(nums[j]<nums[i] && dy[j]>max){  // i번째 애들보다 앞에 있는 원소가 여러개라면  max 값이 큰 원소 찾음 
        max = dy[j];  // dy[j]에 해당되는  , dy[i] 앞에 올수 있는 애들 중 max 값이 더 큰 애들로 갱신  
      }
    }
    dy[i] = max + 1; // i의 앞에 올 원소가 없다면 자기 자신 + 1 해준다 
    answer = Math.max(answer,dy[i]); // dy이에 값에서 가장 큰 값을 출력해줘야한다 
  }
  return answer;
}

console.log(solution([5,3,7,8,6,2,9,4]));